<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>【OC刨根问底】-Runtime简单粗暴理解 | 楚天舒的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="从C的面向过程到接触OC的对象、消息的过渡初期总会有知其然不知其所以然的纠结，相关的学习资源一般都是介绍有什么、使用步骤一二三四的套路，这样就很难知道知道本质是什么，能干什么不能干什么，为什么要选择用它。而实际开发过程，都是先有什么要解决，再努力找到实现方法。人脑的容易接受的信息，也多是主干到分枝的思维导图，纲举目张。所以，试着以自己的粗浅理解来写一点关于OC运行时的东西。
代码的思想，大概是把重">
<meta property="og:type" content="article">
<meta property="og:title" content="【OC刨根问底】-Runtime简单粗暴理解">
<meta property="og:url" content="http://Alfred1003.github.io/2015/10/17/【OC刨根问底】-Runtime简单粗暴理解/index.html">
<meta property="og:site_name" content="楚天舒的技术博客">
<meta property="og:description" content="从C的面向过程到接触OC的对象、消息的过渡初期总会有知其然不知其所以然的纠结，相关的学习资源一般都是介绍有什么、使用步骤一二三四的套路，这样就很难知道知道本质是什么，能干什么不能干什么，为什么要选择用它。而实际开发过程，都是先有什么要解决，再努力找到实现方法。人脑的容易接受的信息，也多是主干到分枝的思维导图，纲举目张。所以，试着以自己的粗浅理解来写一点关于OC运行时的东西。
代码的思想，大概是把重">
<meta property="og:image" content="http://Alfred1003.github.io/Users/Alfred1003/blog/themes/yilia/source/img/metaClass.png">
<meta property="og:updated_time" content="2015-10-20T07:13:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【OC刨根问底】-Runtime简单粗暴理解">
<meta name="twitter:description" content="从C的面向过程到接触OC的对象、消息的过渡初期总会有知其然不知其所以然的纠结，相关的学习资源一般都是介绍有什么、使用步骤一二三四的套路，这样就很难知道知道本质是什么，能干什么不能干什么，为什么要选择用它。而实际开发过程，都是先有什么要解决，再努力找到实现方法。人脑的容易接受的信息，也多是主干到分枝的思维导图，纲举目张。所以，试着以自己的粗浅理解来写一点关于OC运行时的东西。
代码的思想，大概是把重">
  
    <link rel="alternative" href="/atom.xml" title="楚天舒的技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">楚天舒</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/OC/" style="font-size: 10px;">OC</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">少即是多</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">楚天舒</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="img/avatar.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">楚天舒</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-【OC刨根问底】-Runtime简单粗暴理解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/17/【OC刨根问底】-Runtime简单粗暴理解/" class="article-date">
  	<time datetime="2015-10-17T10:57:43.000Z" itemprop="datePublished">2015-10-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      【OC刨根问底】-Runtime简单粗暴理解
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OC/">OC</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>从C的面向过程到接触OC的对象、消息的过渡初期总会有知其然不知其所以然的纠结，相关的学习资源一般都是介绍有什么、使用步骤一二三四的套路，这样就很难知道知道本质是什么，能干什么不能干什么，为什么要选择用它。而实际开发过程，都是先有什么要解决，再努力找到实现方法。人脑的容易接受的信息，也多是主干到分枝的思维导图，纲举目张。所以，试着以自己的粗浅理解来写一点关于OC运行时的东西。</p>
<p>代码的思想，大概是把重复且不变的东西封装成可以重复利用的共性，把变化的东西细化为具体独立松耦合的变量。这些可以是数据类型，也可以是实现的方法代码片段。类也是封装的产物和可封装的对象。被封装的东西，需要找到里面内容来具体地实现，就需要给里面内容加个关联的映射标识，比如索引（数组）、字符串（字典）、指针、SEL（方法的代号）、isa（对象）等等。大概来说就是用类和对象来封装父类指针和方法列表，用映射来找到实现方法的代码片段。</p>
</blockquote>
<hr>
<p>主要思路：</p>
<blockquote>
<p>实例对象instance-&gt;类class-&gt;方法method（-&gt;SEL-&gt;IMP）-&gt;实现函数</p>
</blockquote>
<p>实例对象只存放isa指针和实例变量，由isa指针找到所属类，类维护一个运行时可接收的<code>方法列表</code>；方法列表中的每个入口是一个<code>方法(Method)</code>，其中key是一个特定名称，即<code>选择器(SEL)</code>，其对应一个指向底层C实现函数的指针，即<code>实现(IMP)</code>，。运行时机制最关键核心是objc_msgSend函数，通过给target（类）发送selecter（SEL）来传递消息，找到匹配的IMP，指向实现的C函数。</p>
<p>由于OC的运行时动态特性，在编译之后可以在运行时通过C操作函数，动态地创建修改类信息，动态绑定方法和重写实现，灵活地实现一些自定义功能。</p>
<p>纸上写了个大纲，没有画思维导图，简单列个目录：</p>
<blockquote>
<p>一、运行时Runtime介绍</p>
</blockquote>
<p>二、类的本质：</p>
<pre><code>-<span class="ruby"> 类相关：
</span>        + 数据类型：class，object；
                 -<span class="ruby"> isa 元类
</span>                 -<span class="ruby"> superClass 根类
</span>        + 操作函数:
                  -<span class="ruby"> <span class="keyword">class</span><span class="number">_</span>：
</span>                            + get: 类名，父类; 实例变量，成员变量；属性；实例方法，类方法，方法实现；
                            + copy: 成员变量列表；属性列表；方法列表；协议列表；
                            + add: 成员变量；属性；方法；协议；
                            + replace：属性；方法；
                            + respond:响应方法判断（内省）
                            + isMetaclass:元类判断（内省）
                            + conform:遵循协议判断（内省）
                  -<span class="ruby"> objc<span class="number">_</span>：
</span>                            + get: 实例变量；成员变量；类名；类；元类；关联对象；
                            + copy: 对象；类；类列表；协议列表；
                            + set: 实例变量；成员变量；类；类列表；协议；关联对象；
                            + dispose: 对象；
                  -<span class="ruby"> 动态创建/销毁类、对象
</span>-<span class="ruby"> 成员变量、属性相关：
</span>        + 数据类型：Ivar；objc_property_t；objc_property_attribute_t；
        + 操作函数：
                   -<span class="ruby"> ivar<span class="number">_</span>：
</span>                   -<span class="ruby"> property<span class="number">_</span>：
</span>-<span class="ruby"> 方法消息相关：
</span>        + 数据类型：SEL；IMP; Method；方法缓存
        + 操作函数: 
                   -<span class="ruby"> method<span class="number">_</span>：
</span>                            + invoke: 方法实现的返回值；
                            + get: 方法名；方法实现；参数与返回值相关；
                            + set：方法实现；
                            + exchange：交换方法实现
        + 方法调用：msgSend函数（找到方法实现）
        + 消息转发：
                  -<span class="ruby"> <span class="constant">Method</span> <span class="constant">Resolution</span>
</span>                  -<span class="ruby"> <span class="constant">Fast</span> <span class="constant">Forwarding</span>
</span>                  -<span class="ruby"> <span class="constant">Normal</span> <span class="constant">Forwarding</span>
</span>-<span class="ruby"> 协议相关：
</span>        + 数据类型：Protocol；
        + 操作函数：
                   -<span class="ruby"> protocol<span class="number">_</span>：
</span>                            + get: 协议；属性；
                            + copy：协议列表；属性列表；
                            + add：属性；方法；协议；
                            + isEqual：判断两协议等同；
                            + comform：判断是否遵循协议；
-<span class="ruby"> 其他：类名；版本号；类信息；（忽略）</span>
</code></pre><p>三、 动态实现：</p>
<ul>
<li>Method Swizzling;</li>
<li>ISA Swizzling；</li>
</ul>
<blockquote>
<p>四、 其他概念：category；super；等等。想起来再加…</p>
</blockquote>
<hr>
<p>————进入正题———–</p>
<p>###一、运行时Runtime介绍<br>作用：在程序运行的时候执行编译后的代码，可以:</p>
<pre><code>&gt; 动态（创建）、(修改)、(内省)  <span class="escape">`类</span><span class="escape">`和</span><span class="escape">`方</span>法<span class="escape">`
</span>&gt; 消息传递
</code></pre><p>运行时Runtime的一切都围绕这两个中心：类的动态配置 和 消息传递。通过操作函数来配置类信息，通过msgSend函数传递消息。<br>本质：libobjc.dylib，C和汇编（消息传递机制由汇编写成）写成。</p>
<p>###二、类的本质：</p>
<blockquote>
<p>1、类相关：</p>
</blockquote>
<p>数据结构（本源）:Class类型的结构体。在objc/runtime.h中查看其成员：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_<span class="built_in">AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if !__OBJC2__</span></span><br><span class="line">    Class super_class                       OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 父类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                        OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">long</span> version                            OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 类的版本信息，默认为0</span></span><br><span class="line">    <span class="keyword">long</span> info                               OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 类信息，供运行期使用的一些位标识</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> instance_size                      OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 类的实例变量大小</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars            OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 类的成员变量链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists   OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 方法定义的链表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 方法缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols    OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 协议链表</span></span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure></p>
<p>   a、数据类型：<br><code>isa和super_class</code>   ：不同的类中可以有相同的方法（同一个类的方法不能同名，哪怕参数类型不同，后面解释…），所以要先确定是那个类。isa和super_class是找到实现函数的关键映射，决定找到存放在哪个类的方法实现。（isa用于自省确定所属类，super_class确定继承关系）。</p>
<p> 实例对象的isa指针指向类，类的isa指针指向其元类（metaClass）。对象就是一个含isa指针的结构体。类存储实例对象的方法列表，元类存储类的方法列表，元类也是类对象。<br>这是id类型的结构（类似于C里面的void *）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_<span class="built_in">AVAILABILITY</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure></p>
<p>当创建实例对象时，分配的内存包含一个objc_object数据结构，然后是类到父类直到根类NSObject的实例变量的数据。NSObject类的alloc和allocWithZone:方法使用函数class_createInstance来创建objc_object数据结构。</p>
<p>向一个Objective-C对象发送消息时，运行时库会根据实例对象的<code>isa</code>指针找到这个实例对象所属的类。Runtime库会在类的方法列表由<code>super_class</code>指针找到父类的方法列表直至根类NSObject中去寻找与消息对应的selector指向的方法。找到后即运行这个方法。</p>
<p><img src="/Users/Alfred1003/blog/themes/yilia/source/img/metaClass.png" alt="metaClass.png"></p>
<blockquote>
<p>上图是关于isa和super_class指针的图解：<br>1、isa：实例对象-&gt;类-&gt;元类-&gt;（<code>不经过父元类</code>）直接到根元类（NSObject的元类），<code>根元类的isa指向自己</code>；<br>2、 superclass：类-&gt;父类-&gt;…-&gt;根类NSObject，<code>元类-&gt;父元类-&gt;...-&gt;根元类-&gt;根类</code>,NSObject的superclass指向nil。</p>
</blockquote>
<p>b、操作函数：类对象以class<em>为前缀，实例对象以object</em>为前缀</p>
<ul>
<li>class_：<br>get: 类名，父类，元类；实例变量，成员变量；属性；实例方法，类方法，方法实现；</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的类名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getName ( Class cls );</span><br><span class="line"><span class="comment">// 获取类的父类</span></span><br><span class="line">Class class_getSuperclass ( Class cls );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例大小</span></span><br><span class="line">size_t class_getInstanceSize ( Class cls );</span><br><span class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></span><br><span class="line">Ivar class_getInstanceVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"><span class="comment">// 获取类成员变量的信息</span></span><br><span class="line">Ivar class_getClassVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"><span class="comment">// 获取指定的属性</span></span><br><span class="line">objc_property_t class_getProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line">Method class_getInstanceMethod ( Class cls, SEL name );</span><br><span class="line"><span class="comment">// 获取类方法</span></span><br><span class="line">Method class_getClassMethod ( Class cls, SEL name );</span><br><span class="line"><span class="comment">// 获取方法的具体实现</span></span><br><span class="line">IMP class_getMethodImplementation ( Class cls, SEL name );</span><br><span class="line">IMP class_getMethodImplementation_stret ( Class cls, SEL name );</span><br></pre></td></tr></table></figure>
<p>copy: 成员变量列表；属性列表；方法列表；协议列表；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取整个成员变量列表</span></span><br><span class="line">Ivar * class_copyIvarList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"><span class="comment">// 获取属性列表</span></span><br><span class="line">objc_property_t * class_copyPropertyList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"><span class="comment">// 获取所有方法的列表</span></span><br><span class="line">Method * class_copyMethodList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"><span class="comment">// 获取类实现的协议列表</span></span><br><span class="line">Protocol * class_copyProtocolList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br></pre></td></tr></table></figure>
<p>add: 成员变量；属性；方法；协议；<code>(添加成员变量只能在运行时创建的类，且不能为元类)</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加成员变量</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addIvar ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types );</span><br><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount );</span><br><span class="line"><span class="comment">// 添加方法</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addMethod ( Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types );</span><br><span class="line"><span class="comment">// 添加协议</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addProtocol ( Class cls, Protocol *protocol );</span><br></pre></td></tr></table></figure>
<p> replace：属性；方法；<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换类的属性</span></span><br><span class="line"><span class="keyword">void</span> class_replaceProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount );</span><br><span class="line"><span class="comment">// 替代方法的实现</span></span><br><span class="line">IMP class_replaceMethod ( Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types );</span><br></pre></td></tr></table></figure></p>
<p> respond:响应方法判断（内省）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类实例是否响应指定的selector</span></span><br><span class="line"><span class="built_in">BOOL</span> class_respondsToSelector ( Class cls, SEL sel );</span><br></pre></td></tr></table></figure></p>
<p>isMetaClass:元类判断（内省）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断给定的Class是否是一个元类</span></span><br><span class="line"><span class="built_in">BOOL</span> class_isMetaClass ( Class cls );</span><br></pre></td></tr></table></figure></p>
<p>conform：遵循协议判断（内省）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回类是否实现指定的协议</span></span><br><span class="line"><span class="built_in">BOOL</span> class_conformsToProtocol ( Class cls, Protocol *protocol );</span><br></pre></td></tr></table></figure></p>
<ul>
<li>objc_：<br>get: 实例变量；成员变量；类名；类；元类；关联对象</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对象实例变量</span></span><br><span class="line">Ivar object_getInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **outValue );</span><br><span class="line"><span class="comment">// 获取对象中实例变量的值</span></span><br><span class="line"><span class="keyword">id</span> object_getIvar ( <span class="keyword">id</span> obj, Ivar ivar );</span><br><span class="line"><span class="comment">// 获取对象的类名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * object_getClassName ( <span class="keyword">id</span> obj );</span><br><span class="line"><span class="comment">// 获取对象的类</span></span><br><span class="line">Class object_getClass ( <span class="keyword">id</span> obj );</span><br><span class="line">Class objc_getClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"><span class="comment">// 返回指定类的元类</span></span><br><span class="line">Class objc_getMetaClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"><span class="comment">//获取关联对象</span></span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;myKey);</span><br></pre></td></tr></table></figure>
<p>copy:对象；类；类列表；协议列表；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定对象的一份拷贝</span></span><br><span class="line"><span class="keyword">id</span> object_copy ( <span class="keyword">id</span> obj, size_t size );</span><br><span class="line"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></span><br><span class="line">Class * objc_copyClassList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br></pre></td></tr></table></figure>
<p> set: 实例变量；类；类列表；协议；关联对象；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置类实例的实例变量的值</span></span><br><span class="line">Ivar object_setInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value );</span><br><span class="line"><span class="comment">// 设置对象中实例变量的值</span></span><br><span class="line"><span class="keyword">void</span> object_setIvar ( <span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value );</span><br><span class="line"><span class="comment">//设置关联对象</span></span><br><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">self</span>, &amp;myKey, anObject, OBJC_ASSO<span class="built_in">CIATION_RETAIN</span>);</span><br></pre></td></tr></table></figure>
<p> dispose: 对象；<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放指定对象占用的内存</span></span><br><span class="line"><span class="keyword">id</span> object_dispose ( <span class="keyword">id</span> obj );</span><br></pre></td></tr></table></figure></p>
<ul>
<li>动态创建/销毁类、对象<br>动态创建/销毁类：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新类和元类</span></span><br><span class="line">Class objc_allocateClassPair ( Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁一个类及其相关联的类</span></span><br><span class="line"><span class="keyword">void</span> objc_disposeClassPair ( Class cls );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类</span></span><br><span class="line"><span class="keyword">void</span> objc_registerClassPair ( Class cls );</span><br></pre></td></tr></table></figure>
<p>动态创建/销毁对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类实例</span></span><br><span class="line"><span class="keyword">id</span> class_createInstance ( Class cls, size_t extraBytes );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置创建类实例</span></span><br><span class="line"><span class="keyword">id</span> objc_constructInstance ( Class cls, <span class="keyword">void</span> *bytes );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁类实例</span></span><br><span class="line"><span class="keyword">void</span> * objc_destructInstance ( <span class="keyword">id</span> obj );</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>2、实例变量、属性相关：<br>实例变量和属性也是类对象的关键配置。</p>
</blockquote>
<p>属性变量的意义就是方便让其他对象访问实例变量，另外可以拓展实例变量的作用范围。当然，你可以设置只读或者可写等，设置方法也可自定义。</p>
<p>a、数据类型：<br>Ivar；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> *ivar_name                 OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 变量名</span></span><br><span class="line">    <span class="keyword">char</span> *ivar_type                 OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 变量类型</span></span><br><span class="line">    <span class="keyword">int</span> ivar_offset                 OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 基地址偏移字节</span></span><br><span class="line"><span class="preprocessor">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_property_t(取名可能是因为当时Objective-C1.0还没属性)；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</span><br></pre></td></tr></table></figure>
<p>objc_property_attribute_t（属性的特性有：返回值、是否为atomic、getter/setter名字、是否为dynamic、背后使用的ivar名字、是否为弱引用等）；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;           <span class="comment">// 特性名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *value;          <span class="comment">// 特性值</span></span><br><span class="line">&#125; objc_property_attribute_t;</span><br></pre></td></tr></table></figure>
<p> b、操作函数：</p>
<ul>
<li>ivar_：<br>get：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取成员变量名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getName ( Ivar v );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量类型编码</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getTypeEncoding ( Ivar v );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量的偏移量</span></span><br><span class="line">ptrdiff_t ivar_getOffset ( Ivar v );</span><br></pre></td></tr></table></figure>
<ul>
<li>property_：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取属性名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getName ( objc_property_t property );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性特性描述字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getAttributes ( objc_property_t property );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性中指定的特性</span></span><br><span class="line"><span class="keyword">char</span> * property_copyAttributeValue ( objc_property_t property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性的特性列表</span></span><br><span class="line">objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>3、 方法消息相关：<br>消息传递机制是Runtime的核心，也即消息分派器objc_msgSend。先要知道几个概念。</p>
</blockquote>
<p>a、 数据类型：<br><code>SEL</code>；<br>SEL又叫选择器，是表示一个方法的selector的指针,映射方法的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。<br>SEL的作用是作为IMP的KEY，存储在NSSet中，便于hash快速查询方法。SEL不能相同，对应方法可以不同。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，就算参数类型不同。多个方法可以有同一个SEL。<br>不同的类可以有相同的方法名。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。<br>相关概念：类型编码（Type Encoding）<br>编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的selector关联在一起。可以使用@encode编译器指令来获取它。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure></p>
<p><objc runtime.h="">中没有公开具体的objc_selector结构体成员。但通过log可知SEL本质是一个字符串。</objc></p>
<p><code>IMP</code>;<br>IMP是指向实现函数的指针，通过SEL取得IMP后，我们就获得了最终要找的实现函数的入口。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedefine <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...)</span><br></pre></td></tr></table></figure></p>
<p><code>Method</code>；<br>这个结构体相当于在SEL和IMP之间作了一个绑定。这样有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。（在运行时才将SEL和IMP绑定, 动态配置方法）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL method_name                 OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">char</span> *method_types                  OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 参数类型</span></span><br><span class="line">    IMP method_imp                      OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_method_list 就是用来存储当前类的方法链表，objc_method存储了类的某个方法的信息。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *obsolete                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">int</span> method_count                                                 OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                              OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>方法缓存</code>；<br>方法调用最先是在方法缓存里找的，方法调用是懒调用，第一次调用时加载后加到缓存池里。一个objc程序启动后，需要进行类的初始化、调用方法时的cache初始化，再发送消息的时候就直接走缓存（引申：+load方法和+initialize方法。load方法是首次加载类时调用，绝对只调用一次；initialize方法是首次给类发消息时调用，通常只调用一次，但如果它的子类初始化时未定义initialize方法，则会再调用一次它的initialize方法）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="comment">// 缓存bucket的总数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际缓存bucket的总数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 指向Method数据结构指针的数组</span></span><br><span class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>b、 操作函数: </p>
<ul>
<li>method_：<br>invoke: 方法实现的返回值；</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用指定方法的实现</span></span><br><span class="line"><span class="keyword">id</span> method_invoke ( <span class="keyword">id</span> receiver, Method m, ... );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用返回一个数据结构的方法的实现</span></span><br><span class="line"><span class="keyword">void</span> method_invoke_stret ( <span class="keyword">id</span> receiver, Method m, ... );</span><br></pre></td></tr></table></figure>
<p> get: 方法名；方法实现；参数与返回值相关；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取方法名</span></span><br><span class="line">SEL method_getName ( Method m );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回方法的实现</span></span><br><span class="line">IMP method_getImplementation ( Method m );</span><br><span class="line"><span class="comment">// 获取描述方法参数和返回值类型的字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * method_getTypeEncoding ( Method m );</span><br><span class="line"><span class="comment">// 返回方法的参数的个数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_getNumberOfArguments ( Method m );</span><br><span class="line"><span class="comment">// 通过引用返回方法指定位置参数的类型字符串</span></span><br><span class="line"><span class="keyword">void</span> method_getArgumentType ( Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">char</span> *dst, size_t dst_len );</span><br></pre></td></tr></table></figure>
<p>copy: 返回值类型，参数类型</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取方法的返回值类型的字符串</span></span><br><span class="line"><span class="keyword">char</span> * method_copyReturnType ( Method m );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串</span></span><br><span class="line"><span class="keyword">char</span> * method_copyArgumentType ( Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过引用返回方法的返回值类型字符串</span></span><br><span class="line"><span class="keyword">void</span> method_getReturnType ( Method m, <span class="keyword">char</span> *dst, size_t dst_len );</span><br></pre></td></tr></table></figure>
<p> set：方法实现；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置方法的实现</span></span><br><span class="line">IMP method_setImplementation ( Method m, IMP imp );</span><br></pre></td></tr></table></figure>
<p> exchange：交换方法实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换两个方法的实现</span></span><br><span class="line"><span class="keyword">void</span> method_exchangeImplementations ( Method m1, Method m2 );</span><br></pre></td></tr></table></figure>
<p>description : 方法描述</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定方法的方法描述结构体</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_description * method_getDescription ( Method m );</span><br></pre></td></tr></table></figure>
<ul>
<li>sel_</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定选择器指定的方法的名称</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * sel_getName ( SEL sel );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span></span><br><span class="line">SEL sel_registerName ( <span class="keyword">const</span> <span class="keyword">char</span> *str );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Objective-C Runtime系统中注册一个方法</span></span><br><span class="line">SEL sel_getUid ( <span class="keyword">const</span> <span class="keyword">char</span> *str );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个选择器</span></span><br><span class="line"><span class="built_in">BOOL</span> sel_isEqual ( SEL lhs, SEL rhs );</span><br></pre></td></tr></table></figure>
<p>c、<code>方法调用流程</code>：向对象发送消息，实际上是调用objc_msgSend函数，obj_msgSend的实际动作就是：找到这个函数指针，然后调用它。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend(receiver <span class="keyword">self</span>, selector _cmd, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p>self和_cmd是隐藏参数，在编译期被插入实现代码。<br>self：指向消息的接受者target的对象类型，作为一个占位参数，消息传递成功后self将指向消息的receiver。<br>_cmd: 指向方法实现的SEL类型。</p>
<p>当向一般对象发送消息时，调用objc_msgSend；当向super发送消息时，调用的是objc_msgSendSuper； 如果返回值是一个结构体，则会调用objc_msgSend_stret或objc_msgSendSuper_stret。</p>
<p><code>0.1-检查target是否为nil。如果为nil，直接cleanup，然后return。(这就是我们可以向nil发送消息的原因。)
如果方法返回值是一个对象，那么发送给nil的消息将返回nil；如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者long long的整型标量，发送给nil的消息将返回0；如果方法返回值为结构体,发送给nil的消息将返回0。结构体中各个字段的值将都是0；如果方法的返回值不是上述提到的几种情况，那么发送给nil的消息的返回值将是未定义的。
0.2-如果target非nil，在target的Class中根据Selector去找IMP。（因为同一个方法可能在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到的确切的实现）。</code><br><code>1-首先它找到selector对应的方法实现:
*1.1-在target类的方法缓存列表里检查有没有对应的方法实现，有的话，直接调用。
*1.2-比较请求的selector和类方法列表中的selector，对应的话，直接调用。
*1.3-比较请求的selector和父类方法列表，父类的父类，直至根类，如果有对应，则直接调用。（方法重写拦截父类方法的原理）
2-调用方法实现，并将接收者对象及方法的所有参数传给它。
3-最后，将实现函数的返回值作为自己的返回值。</code></p>
<p>d、<code>动态方法解析与消息转发</code>：如果以上的类中没有找到对应的selector（一般保险起见先用respondsToSelector:内省判断）：，还可以利用消息转发机制依次执行以下流程：</p>
<ul>
<li>Method Resolution（动态方法解析）：<br>用所属类的类方法+（BOOL）resolveInstanceMethod:(实例方法)或者+（BOOL）resolveClassMethod:(类方法),在此方法里添加class_addMethod函数。一般用于@dynamic动态属性。（当一个属性声明为@dynamic，就是向编译器保证编译时不用管/get实现，一定会在运行时实现）。</li>
<li><p>Fast Forwarding （快速消息转发）：<br>如果上一步无法响应消息，调用- (id)forwardingTargetForSelector:(SEL)aSelector方法，将消息接受者转发到另一个对象target（不能为self，否则死循环）。</p>
</li>
<li><p>Normal Forwarding（普通消息转发）：<br>如果上一步无法响应消息：<br>调用方法签名- (NSMethodSignature <em>)methodSignatureForSelector:(SEL)aSelector，方法签名目的将函数的参数类型和返回值封装；<br>如果返回非nil，则创建一个NSInvocation对象利用方法签名和selector封装未被处理的消息，作为参数传递给- (void)forwardInvocation:(NSInvocation </em>)anInvocation。<br>这一步比较耗时。</p>
</li>
</ul>
<p>如果以上步骤（消息传递和消息转发）还是不能响应消息，则调动doesNotRecognizeSelector：方法，抛出异常。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unrecognized selector sent to instance</span><br></pre></td></tr></table></figure></p>
<p>(消息转发可以利用转移消息接受对象，实现伪多重继承的效果。)</p>
<hr>
<blockquote>
<p>4、 协议相关：@protocol声明了可以被其他任何类实现的方法，协议仅仅是定义一个接口，而由其他的类去负责实现。</p>
</blockquote>
<p> 数据类型：Protocol；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object Protocol;</span><br></pre></td></tr></table></figure>
<p>protocol是一个对象结构体。</p>
<p> 操作函数：</p>
<ul>
<li>objc_:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定的协议</span></span><br><span class="line">Protocol * objc_getProtocol ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运行时所知道的所有协议的数组</span></span><br><span class="line">Protocol ** objc_copyProtocolList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的协议实例</span></span><br><span class="line">Protocol * objc_allocateProtocol ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时中注册新创建的协议</span></span><br><span class="line"><span class="keyword">void</span> objc_registerProtocol ( Protocol *proto );</span><br></pre></td></tr></table></figure>
<ul>
<li>protocol_：<br>get: 协议；属性；</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回协议名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * protocol_getName ( Protocol *p );</span><br><span class="line"><span class="comment">// 获取协议的指定属性</span></span><br><span class="line">objc_property_t protocol_getProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty );</span><br></pre></td></tr></table></figure>
<p> copy：协议列表；属性列表；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取协议中的属性列表</span></span><br><span class="line">objc_property_t * protocol_copyPropertyList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"><span class="comment">// 获取协议采用的协议</span></span><br><span class="line">Protocol ** protocol_copyProtocolList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br></pre></td></tr></table></figure>
<p> add：属性；方法；协议；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为协议添加方法</span></span><br><span class="line"><span class="keyword">void</span> protocol_addMethodDescription ( Protocol *proto, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个已注册的协议到协议中</span></span><br><span class="line"><span class="keyword">void</span> protocol_addProtocol ( Protocol *proto, Protocol *addition );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加属性</span></span><br><span class="line"><span class="keyword">void</span> protocol_addProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty );</span><br></pre></td></tr></table></figure>
<p> isEqual：判断两协议等同；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试两个协议是否相等</span></span><br><span class="line"><span class="built_in">BOOL</span> protocol_isEqual ( Protocol *proto, Protocol *other );</span><br></pre></td></tr></table></figure>
<p> comform：判断是否遵循协议；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看协议是否采用了另一个协议</span></span><br><span class="line"><span class="built_in">BOOL</span> protocol_conformsToProtocol ( Protocol *proto, Protocol *other );</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>5、 其他：类名；版本号；类信息；（忽略）</p>
</blockquote>
<hr>
<p>三、 动态实现：</p>
<ul>
<li>Method Swizzling;<br>Method Swizzling可以在运行时通过修改类的方法列表中selector对应的函数或者设置交换方法实现，来动态修改方法。可以重写某个方法而不用继承，同时还可以调用原先的实现。通常应用于在category中添加一个方法。<br>为保证改变方法引起冲突，确保方法混用只能一次性：<br>比如，在+load方法或者dispatch_once中执行。</li>
<li>ISA Swizzling；<br>ISA Swizzling可以动态修改对象的isa指针，改变对象的类，类似于创建子类实现相同的功能。KVO即是同过ISA Swizzling实现的。</li>
</ul>
<hr>
<blockquote>
<p>四、 其他概念：category；super；</p>
</blockquote>
<ul>
<li>category:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_category *Category;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_category &#123;</span><br><span class="line">    <span class="keyword">char</span> *category_name                          OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 分类名</span></span><br><span class="line">    <span class="keyword">char</span> *class_name                             OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 分类所属的类名</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *instance_methods    OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *class_methods       OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols         OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 分类所实现的协议列表</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-runtime-new.h中定义：</span></span><br><span class="line"><span class="keyword">struct</span> category_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;                        <span class="comment">// name 是指 class_name 而不是 category_name</span></span><br><span class="line">    classref_t cls;                          <span class="comment">// cls是要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对应到对应的类对象</span></span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;       </span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;</span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;    <span class="comment">// instanceProperties表示Category里所有的properties，(这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，)不过这个和一般的实例变量是不一样的</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  category就是定义方法的结构体，instance_methods列表是objc_class中方法列表的一个子集，class_methods列表是元类方法列表的一个子集。由其结构成员可知，category为什么不能添加成员变量（可添加属性，只有set/get方法）。</p>
<p>给category添加方法后，category_list会生成method list。这个方法列表是倒序添加的，也就是说，新生成的category的方法会先于旧的category的方法插入。（category的方法会优先于类方法执行）。</p>
<ul>
<li>super：</li>
</ul>
<p>super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用方法时，跳过当前类去调用父类的方法，而不是本类中的方法。self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。实际上给super发消息时，super还是与self指向的是相同的消息接收者。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">   __unsafe_unretained <span class="keyword">id</span> receiver;</span><br><span class="line">   __unsafe_unretained Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原理：使用super来接收消息时，编译器会生成一个objc_super结构体。发送消息时，不是调用objc_msgSend函数，而是调用objc_msgSendSuper函数:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSendSuper ( <span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ... );</span><br></pre></td></tr></table></figure>
<p> 该函数实际的操作是：从objc_super结构体指向的superClass的方法列表开始查找selector，找到后以objc-&gt;receiver去调用这个selector。</p>
<ul>
<li>Runtime开源源码对一些方法的实现：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (Class)class ;</span><br><span class="line"></span><br><span class="line">- (Class)class &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)class;</span><br><span class="line"></span><br><span class="line">+ (Class)class &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isKindOf:aClass;<span class="comment">// (for循环遍历父类，每次判断返回的结果可能不同)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isKindOf:aClass</span><br><span class="line">&#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">for</span> (cls = isa; cls; cls = cls-&gt;superclass) </span><br><span class="line">        <span class="keyword">if</span> (cls == (Class)aClass)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isMemberOf:aClass;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMemberOf:aClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> isa == (Class)aClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/10/20/【iOS程序启动与运转】- RunLoop个人小结/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          【iOS程序启动与运转】- RunLoop个人小结.md
        
      </div>
    </a>
  
  
    <a href="/2015/10/17/UIKit的外观属性及方法汇总/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">UIKit的外观属性及方法汇总.md</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="【OC刨根问底】-Runtime简单粗暴理解" data-title="【OC刨根问底】-Runtime简单粗暴理解" data-url="http://Alfred1003.github.io/2015/10/17/【OC刨根问底】-Runtime简单粗暴理解/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 楚天舒
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>