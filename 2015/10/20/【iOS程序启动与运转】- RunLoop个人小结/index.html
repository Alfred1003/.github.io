<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>【iOS程序启动与运转】- RunLoop个人小结.md | 楚天舒的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习iOS开发一般都是从UI开始的，从只知道从IB拖控件，到知道怎么在方法里写代码，然后会显示什么样的视图，产生什么样的事件，等等。其实程序从启动开始，一直都是按照苹果封装好的代码运行着，暴露的一些属性和方法作为接口，是让我们在给定的方法里写代码实现自定义功能，做出各种各样的应用。这些方法的调用顺序最为关键，熟悉了程序运转和方法调用的顺序，才可以更好地操控程序和代码，尽量避免Xcode不报错又实现">
<meta property="og:type" content="article">
<meta property="og:title" content="【iOS程序启动与运转】- RunLoop个人小结.md">
<meta property="og:url" content="http://Alfred1003.github.io/2015/10/20/【iOS程序启动与运转】- RunLoop个人小结/index.html">
<meta property="og:site_name" content="楚天舒的技术博客">
<meta property="og:description" content="学习iOS开发一般都是从UI开始的，从只知道从IB拖控件，到知道怎么在方法里写代码，然后会显示什么样的视图，产生什么样的事件，等等。其实程序从启动开始，一直都是按照苹果封装好的代码运行着，暴露的一些属性和方法作为接口，是让我们在给定的方法里写代码实现自定义功能，做出各种各样的应用。这些方法的调用顺序最为关键，熟悉了程序运转和方法调用的顺序，才可以更好地操控程序和代码，尽量避免Xcode不报错又实现">
<meta property="og:image" content="http://Alfred1003.github.io/Users/Alfred1003/blog/themes/yilia/source/img/Runloop_network.png">
<meta property="og:updated_time" content="2015-10-20T07:12:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【iOS程序启动与运转】- RunLoop个人小结.md">
<meta name="twitter:description" content="学习iOS开发一般都是从UI开始的，从只知道从IB拖控件，到知道怎么在方法里写代码，然后会显示什么样的视图，产生什么样的事件，等等。其实程序从启动开始，一直都是按照苹果封装好的代码运行着，暴露的一些属性和方法作为接口，是让我们在给定的方法里写代码实现自定义功能，做出各种各样的应用。这些方法的调用顺序最为关键，熟悉了程序运转和方法调用的顺序，才可以更好地操控程序和代码，尽量避免Xcode不报错又实现">
  
    <link rel="alternative" href="/atom.xml" title="楚天舒的技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">楚天舒</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/OC/" style="font-size: 10px;">OC</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">少即是多</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">楚天舒</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="img/avatar.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">楚天舒</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-【iOS程序启动与运转】- RunLoop个人小结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/20/【iOS程序启动与运转】- RunLoop个人小结/" class="article-date">
  	<time datetime="2015-10-20T06:57:52.000Z" itemprop="datePublished">2015-10-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      【iOS程序启动与运转】- RunLoop个人小结.md
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>学习iOS开发一般都是从UI开始的，从只知道从IB拖控件，到知道怎么在方法里写代码，然后会显示什么样的视图，产生什么样的事件，等等。其实程序从启动开始，一直都是按照苹果封装好的代码运行着，暴露的一些属性和方法作为接口，是让我们在给定的方法里写代码实现自定义功能，做出各种各样的应用。这些方法的调用顺序最为关键，熟悉了程序运转和方法调用的顺序，才可以更好地操控程序和代码，尽量避免Xcode不报错又实现不了功能的BUG。从Xcode的线程函数调用栈可以看到一些方法调用顺序。</p>
</blockquote>
<hr>
<p>#####–零–从程序启动开始到view显示：</p>
<p>start-&gt;(加载framework，动态静态链接库，启动图片，Info.plist等)-&gt;main函数-&gt;UIApplicationMain函数：</p>
<pre><code>-<span class="ruby"> 初始化<span class="constant">UIApplication</span>单例对象
</span>-<span class="ruby"> 初始化<span class="constant">AppDelegate</span>对象，并设为<span class="constant">UIApplication</span>对象的代理
</span>-<span class="ruby"> 检查<span class="constant">Info</span>.plist设置的xib文件是否有效，如果有则解冻<span class="constant">Nib</span>文件并设置outlets，创建显示key window、rootViewController、与rootViewController关联的根view（没有关联则看rootViewController同名的xib），否则launch之后由程序员手动加载。
</span>-<span class="ruby"> 建立一个主事件循环，其中包含<span class="constant">UIApplication</span>的<span class="constant">Runloop</span>来开始处理事件。</span>
</code></pre><blockquote>
<p><code>UIApplication</code>：<br>1、通过window管理视图；<br>2、发送Runloop封装好的control消息给target；<br>3、处理URL，应用图标警告，联网状态，状态栏，远程事件等。<br><code>AppDelegate</code>：<br>管理UIApplication生命周期和应用的五种状态(notRunning/inactive/active/background/suspend)。<br><code>Key Window</code>：<br>1、显示view；<br>2、管理rootViewcontroller生命周期；<br>3、发送UIApplication传来的事件消息给view。<br><code>rootViewController</code>：<br>1、管理view（view生命周期；view的数据源/代理；view与superView之间事件响应nextResponder的“备胎”）;<br>2、界面跳转与传值；<br>3、状态栏，屏幕旋转。<br><code>view</code>：<br>1、通过作为CALayer的代理，管理layer的渲染（顺序大概是先更新约束，再layout再display）和动画（默认layer的属性可动画，view默认禁止，在UIView的block分类方法里才打开动画）。layer是RGBA纹理，通过和mask位图（含alpha属性）关联将合成后的layer纹理填充在像素点内，GPU每1/60秒将计算出的纹理display在像素点中。<br>2、布局子控件（屏幕旋转或者子视图布局变动时，view会重新布局）。<br>3、事件响应：event和guesture。<br>插播控制器生命周期<br><code>runloop</code>:<br>1、（要让马儿跑）通过do-while死循环让程序持续运行：接收用户输入，调度处理事件时间。<br>2、（要让马儿少吃草）通过mach_msg()让runloop没事时进入trap状态，节省CPU资源。</p>
</blockquote>
<hr>
<p>关于程序启动原理以及各个控件的资料，已经有太多资料介绍，平时我们也经常接触经常用到，但关于Runloop的资料，官方文档总是太过简练，网上资源说法也不太统一，只能从CFRunLoopRef开源代码着手，试着学习总结下。（NSRunloop是对CFRunloopRef的面向对象封装，但是不是线程安全）。</p>
<hr>
<p>####–一–Runloop</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1、与线程和自动释放池相关：</span><br><span class="line"></span><br><span class="line">2、CFRunLoopRef构造：数据结构；创建与退出；mode切换和item依赖；Runloop启动</span><br><span class="line">         -<span class="ruby"> <span class="constant">CFRunLoopModeRef</span>：数据结构（与<span class="constant">CFRunLoopRef</span>放一起了）；创建；类型；</span><br><span class="line"></span>           modeItems：- CFRunLoopSourceRef：数据结构（source0/source1）；</span><br><span class="line">                             -<span class="ruby"> source<span class="number">0</span> ：</span><br><span class="line"></span>                             -<span class="ruby"> source1 ：</span><br><span class="line"></span>                      -<span class="ruby"> <span class="constant">CFRunLoopTimerRef</span>：数据结构；创建与生效；相关类型（<span class="constant">GCD</span>的timer与<span class="constant">CADisplayLink</span>)</span><br><span class="line"></span>                      -<span class="ruby"> <span class="constant">CFRunLoopObserverRef</span>：数据结构；创建与添加；监听的状态；</span><br><span class="line"></span>3、Runloop内部逻辑：关键在两个判断点（是否睡觉，是否退出）</span><br><span class="line">         -<span class="ruby"> 代码实现：</span><br><span class="line"></span>         -<span class="ruby"> 函数作用栈显示：</span><br><span class="line"></span></span><br><span class="line">4、Runloop本质：mach port和mach_msg()。</span><br><span class="line"></span><br><span class="line">5、如何处理事件：</span><br><span class="line">         -<span class="ruby"> 界面刷新：</span><br><span class="line"></span>         -<span class="ruby"> 手势识别：</span><br><span class="line"></span>         -<span class="ruby"> <span class="constant">GCD</span>任务：</span><br><span class="line"></span>         -<span class="ruby"> timer：（与<span class="constant">CADisplayLink</span>）</span><br><span class="line"></span>         -<span class="ruby"> 网络请求：</span><br><span class="line"></span></span><br><span class="line">6、应用：</span><br><span class="line">         -<span class="ruby"> 滑动与图片刷新；</span><br><span class="line"></span>         -<span class="ruby"> 常驻子线程，保持子线程一直处理事件</span></span><br></pre></td></tr></table></figure>
<hr>
<p>###Runloop</p>
<blockquote>
<p>1、与线程和自动释放池相关：</p>
</blockquote>
<p>Runloop的寄生于线程：一个线程只能有唯一对应的runloop；但这个根runloop里可以嵌套子runloops；<br>自动释放池寄生于Runloop：程序启动后，主线程注册了两个Observer监听runloop的进出与睡觉。一个最高优先级OB监测Entry状态；一个最低优先级OB监听BeforeWaiting状态和Exit状态。<br>           线程(创建)–&gt;runloop将进入–&gt;最高优先级OB创建释放池–&gt;runloop将睡–&gt;最低优先级OB销毁旧池创建新池–&gt;runloop将退出–&gt;最低优先级OB销毁新池–&gt;线程(销毁)</p>
<hr>
<blockquote>
<p>2、CFRunLoopRef构造：</p>
</blockquote>
<p>数据结构：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runloop数据结构</span></span><br><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoopMode</span> &#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;            <span class="comment">// Mode名字, </span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;    <span class="comment">// Set&lt;CFRunLoopSourceRef&gt;</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;    <span class="comment">// Set&lt;CFRunLoopSourceRef&gt;</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// Array&lt;CFRunLoopObserverRef&gt;</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;    <span class="comment">// Array&lt;CFRunLoopTimerRef&gt;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// mode数据结构</span></span><br><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoop</span> &#123;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     <span class="comment">// Set&lt;CFStringRef&gt;</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;           <span class="comment">// Set&lt;CFRunLoopModeRef&gt;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建与退出：mode切换和item依赖</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a 主线程的runloop自动创建，子线程的runloop默认不创建（在子线程中调用NSRunLoop *runloop = [NSRunLoop currentRunLoop];</span><br><span class="line">获取RunLoop对象的时候，就会创建RunLoop）；</span><br><span class="line"></span><br><span class="line">b runloop退出的条件：app退出；线程关闭；设置最大时间到期；modeItem为空；</span><br><span class="line"></span><br><span class="line">c 同一时间一个runloop只能在一个<span class="built_in">mode</span>，切换<span class="built_in">mode</span>只能退出runloop，再重进指定<span class="built_in">mode</span>（隔离modeItems使之互不干扰）；</span><br><span class="line"></span><br><span class="line">d 一个item可以加到不同<span class="built_in">mode</span>；一个<span class="built_in">mode</span>被标记到commonModes里（这样runloop不用切换<span class="built_in">mode</span>）。</span><br></pre></td></tr></table></figure>
<p>启动Runloop：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用DefaultMode启动</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), k<span class="built_in">CFRunLoopDefaultMode</span>, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 用指定的Mode启动，允许设置RunLoop最大时间（假无限循环），执行完毕是否退出</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>CFRunLoopModeRef：<br>数据结构（见上）；<br>创建添加：runloop自动创建对应的mode；mode只能添加不能删除<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加mode</span></span><br><span class="line"><span class="built_in">CFRunLoopAddCommonMode</span>(<span class="built_in">CFRunLoopRef</span> runloop, <span class="built_in">CFStringRef</span> modeName);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>类型：</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. kCFRunLoopDefaultMode: 默认 <span class="built_in">mode</span>，通常主线程在这个 <span class="built_in">Mode</span> 下运行。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. UITrackingRunLoopMode: 追踪<span class="built_in">mode</span>，保证Scrollview滑动顺畅不受其他 <span class="built_in">mode</span> 影响。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. UIInitializationRunLoopMode: 启动程序后的过渡<span class="built_in">mode</span>，启动完成后就不再使用。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>: GSEventReceiveRunLoopMode: Graphic相关事件的<span class="built_in">mode</span>，通常用不到。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>: kCFRunLoopCommonModes: 占位<span class="built_in">mode</span>，作为标记DefaultMode和CommonMode用。</span><br></pre></td></tr></table></figure>
<ul>
<li>modeItems：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加移除item的函数（参数：添加/移除哪个item到哪个runloop的哪个mode下）</span></span><br><span class="line"><span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopAddTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopRemoveSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopRemoveObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopRemoveTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</span><br></pre></td></tr></table></figure>
<p>A– CFRunLoopSourceRef：事件来源</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">按照官方文档CFRunLoopSourceRef为<span class="number">3</span>类，但数据结构只有两类（？？？）</span><br><span class="line">Port-Based Source<span class="variable">s:</span>与内核端口相关</span><br><span class="line">Custom Input Source<span class="variable">s:</span>与自定义<span class="keyword">source</span>相关</span><br><span class="line">Cocoa Perform Selector Source<span class="variable">s:</span>与PerformSEL方法相关）</span><br></pre></td></tr></table></figure>
<p>数据结构（source0/source1）；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// source0 (manual): order(优先级)，callout(回调函数)</span></span><br><span class="line"><span class="built_in">CFRunLoopSource</span> &#123;order =..., &#123;callout =... &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// source1 (mach port)：order(优先级)，port:(端口), callout(回调函数)</span></span><br><span class="line"><span class="built_in">CFRunLoopSource</span> &#123;order = ..., &#123;port = ..., callout =...&#125;</span><br></pre></td></tr></table></figure>
<p><code>source0</code>：event事件，只含有回调，需要标记待处理（signal），然后手动将runloop唤醒（wakeup）；<br><code>source1</code> ：包含一个 mach_port 和一个回调，被用于通过内核和其他线程发送的消息，能主动唤醒runloop。</p>
<p>B– CFRunLoopTimerRef：系统内“定时闹钟”</p>
<p>NSTimer和performSEL方法实际上是对CFRunloopTimerRef的封装；runloop启动时设置的最大超时时间实际上是GCD的dispatch_source_t类型。</p>
<p>数据结构:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Timer：interval:(闹钟间隔), tolerance:(延期时间容忍度)，callout(回调函数)</span></span><br><span class="line"><span class="built_in">CFRunLoopTimer</span> &#123;firing =..., interval = ...,tolerance = ...,next fire date = ...,callout = ...&#125;</span><br></pre></td></tr></table></figure>
<p>创建与生效；</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NSTimer：</span></span><br><span class="line">  <span class="comment">// 创建一个定时器（需要手动加到runloop的mode中）</span></span><br><span class="line"> + (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti invocation:(<span class="built_in">NSInvocation</span> *)invocation repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 默认已经添加到主线程的runLoop的DefaultMode中 </span></span><br><span class="line"> + (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti invocation:(<span class="built_in">NSInvocation</span> *)invocation repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// performSEL方法</span></span><br><span class="line"><span class="comment">// 内部会创建一个Timer到当前线程的runloop中（如果当前线程没runloop则方法无效；performSelector:onThread: 方法放到指定线程runloop中）</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay</span><br></pre></td></tr></table></figure>
<p>相关类型（GCD的timer与CADisplayLink)</p>
<p>GCD的timer：<br>dispatch_source_t 类型，可以精确的参数，不用以来runloop和mode，性能消耗更小。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_set_timer(dispatch_source_t source, <span class="comment">// 定时器对象</span></span><br><span class="line">                              dispatch_time_t start, <span class="comment">// 定时器开始执行的时间</span></span><br><span class="line">                              uint64_t interval, <span class="comment">// 定时器的间隔时间</span></span><br><span class="line">                              uint64_t leeway <span class="comment">// 定时器的精度</span></span><br><span class="line">                              );</span><br></pre></td></tr></table></figure>
<p>CADisplayLink ：<br>Timer的tolerance表示最大延期时间，如果因为阻塞错过了这个时间精度，这个时间点的回调也会跳过去，不会延后执行。<br>CADisplayLink 是一个和屏幕刷新率一致的定时器，如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似，只是没有tolerance容忍时间），造成界面卡顿的感觉。</p>
<p>C–CFRunLoopObserverRef：监听runloop状态，接收回调信息（常见于自动释放池创建销毁）</p>
<p>数据结构:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Observer：order(优先级)，ativity(监听状态)，callout(回调函数)</span></span><br><span class="line"><span class="built_in">CFRunLoopObserver</span> &#123;order = ..., activities = ..., callout = ...&#125;</span><br></pre></td></tr></table></figure>
<p>创建与添加；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数用于分配该observer对象的内存空间</span></span><br><span class="line"><span class="comment">// 第二个参数用以设置该observer监听什么状态</span></span><br><span class="line"><span class="comment">// 第三个参数用于标识该observer是在第一次进入run loop时执行还是每次进入run loop处理时均执行</span></span><br><span class="line"><span class="comment">// 第四个参数用于设置该observer的优先级,一般为0</span></span><br><span class="line"><span class="comment">// 第五个参数用于设置该observer的回调函数</span></span><br><span class="line"><span class="comment">// 第六个参数observer的运行状态   </span></span><br><span class="line"><span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(), k<span class="built_in">CFRunLoopAllActivities</span>, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">      <span class="comment">// 执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>监听的状态；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    k<span class="built_in">CFRunLoopEntry</span>         = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeTimers</span>  = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeSources</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeWaiting</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    k<span class="built_in">CFRunLoopAfterWaiting</span>  = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    k<span class="built_in">CFRunLoopExit</span>          = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>3、Runloop内部逻辑：关键在两个判断点（是否睡觉，是否退出）</p>
</blockquote>
<ul>
<li>代码实现：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// RunLoop的实现</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunSpecific</span>(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0.1 根据modeName找到对应mode</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __<span class="built_in">CFRunLoopFindMode</span>(runloop, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 0.2 如果mode里没有source/timer/observer, 直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (__<span class="built_in">CFRunLoopModeIsEmpty</span>(currentMode)) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.1 通知 Observers: RunLoop 即将进入 loop。---（OB会创建释放池）</span></span><br><span class="line">    __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopEntry</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.2 内部函数，进入loop</span></span><br><span class="line">    __<span class="built_in">CFRunLoopRun</span>(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 2.1 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopBeforeTimers</span>);</span><br><span class="line">            <span class="comment">// 2.2 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopBeforeSources</span>);</span><br><span class="line">            <span class="comment">// 执行被加入的block</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoBlocks</span>(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2.3 RunLoop 触发 Source0 (非port) 回调。</span></span><br><span class="line">            sourceHandledThisLoop = __<span class="built_in">CFRunLoopDoSources0</span>(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            <span class="comment">// 执行被加入的block</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoBlocks</span>(runloop, currentMode);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 2.4 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></span><br><span class="line">            <span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __<span class="built_in">CFRunLoopServiceMachPort</span>(dispatchPort, &amp;msg)</span><br><span class="line">                <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3.1 如果没有待处理消息，通知 Observers: RunLoop 的线程即将进入休眠(sleep)。--- (OB会销毁释放池并建立新释放池)</span></span><br><span class="line">            <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopBeforeWaiting</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3.2. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></span><br><span class="line">            <span class="comment">// -  一个基于 port 的Source1 的事件。</span></span><br><span class="line">            <span class="comment">// -  一个 Timer 到时间了</span></span><br><span class="line">            <span class="comment">// -  RunLoop 启动时设置的最大超时时间到了</span></span><br><span class="line">            <span class="comment">// -  被手动唤醒</span></span><br><span class="line">            __<span class="built_in">CFRunLoopServiceMachPort</span>(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 3.3. 被唤醒，通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopAfterWaiting</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4.0 处理消息。</span></span><br><span class="line">            handle_msg:</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 4.1 如果消息是Timer类型，触发这个Timer的回调。</span></span><br><span class="line">            <span class="keyword">if</span> (msg_is_timer) &#123;</span><br><span class="line">                __<span class="built_in">CFRunLoopDoTimers</span>(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 4.2 如果消息是dispatch到main_queue的block，执行block。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</span><br><span class="line">                __<span class="built_in">CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span>(msg);</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 4.3 如果消息是Source1类型，处理这个事件</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopSourceRef</span> source1 = __<span class="built_in">CFRunLoopModeFindSourceForMachPort</span>(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __<span class="built_in">CFRunLoopDoSource1</span>(runloop, currentMode, source1, msg);</span><br><span class="line">                <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行加入到Loop的block</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoBlocks</span>(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">           </span><br><span class="line">            <span class="comment">// 5.1 如果处理事件完毕，启动Runloop时设置参数为一次性执行,设置while参数退出Runloop</span></span><br><span class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                retVal = k<span class="built_in">CFRunLoopRunHandledSource</span>;</span><br><span class="line">            <span class="comment">// 5.2 如果启动Runloop时设置的最大运转时间到期，设置while参数退出Runloop</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                retVal = k<span class="built_in">CFRunLoopRunTimedOut</span>;</span><br><span class="line">            <span class="comment">// 5.3 如果启动Runloop被外部调用强制停止，设置while参数退出Runloop</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__<span class="built_in">CFRunLoopIsStopped</span>(runloop)) &#123;</span><br><span class="line">                retVal = k<span class="built_in">CFRunLoopRunStopped</span>;</span><br><span class="line">            <span class="comment">// 5.4 如果启动Runloop的modeItems为空，设置while参数退出Runloop</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__<span class="built_in">CFRunLoopModeIsEmpty</span>(runloop, currentMode)) &#123;</span><br><span class="line">                retVal = k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5.5 如果没超时，mode里没空，loop也没被停止，那继续loop，回到第2步循环。</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 如果第6步判断后loop退出，通知 Observers: RunLoop 退出。--- (OB会销毁新释放池)</span></span><br><span class="line">    __<span class="built_in">CFRunLoopDoObservers</span>(rl, currentMode, k<span class="built_in">CFRunLoopExit</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数作用栈显示：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.1 通知Observers，即将进入RunLoop</span></span><br><span class="line">    <span class="comment">// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span></span><br><span class="line">    __<span class="built_in">CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(k<span class="built_in">CFRunLoopEntry</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2.1 通知 Observers: 即将触发 Timer 回调。</span></span><br><span class="line">        __<span class="built_in">CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(k<span class="built_in">CFRunLoopBeforeTimers</span>);</span><br><span class="line">        <span class="comment">// 2.2 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span></span><br><span class="line">        __<span class="built_in">CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(k<span class="built_in">CFRunLoopBeforeSources</span>);</span><br><span class="line">         <span class="comment">// 执行Block</span></span><br><span class="line">        __<span class="built_in">CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span>(block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2.3 触发 Source0 (非基于port的) 回调。</span></span><br><span class="line">        __<span class="built_in">CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span>(source0);</span><br><span class="line">        <span class="comment">// 执行Block</span></span><br><span class="line">        __<span class="built_in">CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span>(block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 3.1 通知Observers，即将进入休眠</span></span><br><span class="line">        <span class="comment">// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span></span><br><span class="line">        __<span class="built_in">CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(k<span class="built_in">CFRunLoopBeforeWaiting</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 3.2 sleep to wait msg.</span></span><br><span class="line">        mach_msg() -&gt; mach_msg_trap();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.3 通知Observers，线程被唤醒</span></span><br><span class="line">        __<span class="built_in">CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(k<span class="built_in">CFRunLoopAfterWaiting</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 4.1 如果是被Timer唤醒的，回调Timer</span></span><br><span class="line">        __<span class="built_in">CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span>(timer);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 4.2 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span></span><br><span class="line">        __<span class="built_in">CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span>(dispatched_block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 4.3 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span></span><br><span class="line">        __<span class="built_in">CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span>(source1);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 5. 退出判断函数调用栈无显示</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (...);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 6. 通知Observers，即将退出RunLoop</span></span><br><span class="line">    <span class="comment">// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span></span><br><span class="line">    __<span class="built_in">CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(k<span class="built_in">CFRunLoopExit</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一步一步写具体的实现逻辑过于繁琐不便理解，按Runloop状态大致分为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>- Entry：通知OB（创建pool）；</span><br><span class="line"><span class="number">2</span>- 执行阶段：按顺序通知OB并执行timer，source0；若有source1执行source1；</span><br><span class="line"><span class="number">3</span>- 休眠阶段：利用mach_msg判断进入休眠，通知OB（pool的销毁重建）；被消息唤醒通知OB；</span><br><span class="line"><span class="number">4</span>- 执行阶段：按消息类型处理事件；</span><br><span class="line"><span class="number">5</span>- 判断退出条件：如果符合退出条件（一次性执行，超时，强制停止，modeItem为空）则退出，否则回到第<span class="number">2</span>阶段；</span><br><span class="line"><span class="number">6</span>- Exit：通知OB（销毁pool）。</span><br></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>4、Runloop本质：mach port和mach_msg()。</p>
</blockquote>
<p>Mach是XNU的内核，进程、线程和虚拟内存等对象通过端口发消息进行通信，Runloop通过mach_msg()函数发送消息，如果没有port 消息，内核会将线程置于等待状态 mach_msg_trap() 。如果有消息，判断消息类型处理事件，并通过modeItem的callback回调(<code>处理事件的具体执行是在DoBlock里还是在回调里目前我还不太明白？？？</code>)。</p>
<p>Runloop有两个关键判断点，一个是通过msg决定Runloop是否等待，一个是通过判断退出条件来决定Runloop是否循环。</p>
<hr>
<blockquote>
<p>5、如何处理事件：</p>
</blockquote>
<ul>
<li><p>界面刷新：<br>当UI改变（ Frame变化、 UIView/CALayer 的继承结构变化等）时，或手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理。<br>苹果注册了一个用来监听BeforeWaiting和Exit的Observer，在它的回调函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
</li>
<li><p>事件响应：<br>当一个硬件事件(触摸/锁屏/摇晃/加速等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收， 随后由mach port 转发给需要的App进程。<br>苹果注册了一个 Source1 (基于 mach port 的) 来接收系统事件，通过回调函数触发Sourece0（所以UIEvent实际上是基于Source0的），调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。<br>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。</p>
</li>
<li><p>手势识别：<br>如果上一步的 _UIApplicationHandleEventQueue() 识别到是一个guesture手势，会调用Cancel方法将当前的touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。<br>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，其回调函数为 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。<br>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
</li>
<li><p>GCD任务：<br>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调里执行这个 block。Runloop只处理主线程的block，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
</li>
<li><p>timer：（见上modeItem部分）</p>
</li>
</ul>
<ul>
<li>网络请求：<br>关于网络请求的接口:最底层是CFSocket层，然后是CFNetwork将其封装，然后是NSURLConnection对CFNetwork进行面向对象的封装，NSURLSession 是 iOS7 中新增的接口，也用到NSURLConnection的loader线程。所以还是以NSURLConnection为例。<br>当开始网络传输时，NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。<br><img src="/Users/Alfred1003/blog/themes/yilia/source/img/Runloop_network.png" alt="RunLoop_network.png"></li>
</ul>
<hr>
<blockquote>
<p>6、应用：</p>
</blockquote>
<ul>
<li>滑动与图片刷新；<br>当tableview的cell上有需要从网络获取的图片的时候，滚动tableView，异步线程会去加载图片，加载完成后主线程就会设置cell的图片，但是会造成卡顿。可以让设置图片的任务在CFRunLoopDefaultMode下进行，当滚动tableView的时候，RunLoop是在 UITrackingRunLoopMode 下进行，不去设置图片，而是当停止的时候，再去设置图片。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">  [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">  <span class="comment">// 只在NSDefaultRunLoopMode下执行(刷新图片)</span></span><br><span class="line">  [<span class="keyword">self</span><span class="variable">.myImageView</span> performSelector:<span class="keyword">@selector</span>(setImage:) withObject:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@""</span>] afterDelay:ti inModes:@[<span class="built_in">NSDefaultRunLoopMode</span>]];    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>常驻子线程，保持子线程一直处理事件<br>为了保证线程长期运转，可以在子线程中加入RunLoop，并且给Runloop设置item，防止Runloop自动退出。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"AFNetworking"</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.lock</span> lock];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> class] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span><span class="variable">.runLoopModes</span> allObjects]];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.state</span> = AFOperationExecutingState;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> class] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span><span class="variable">.runLoopModes</span> allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.lock</span> unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一篇综合官方文档、<a href="http://objccn.io/issue-3-1/" target="_blank" rel="external">绘制像素到屏幕上</a>、<a href="http://objccn.io/issue-12-4/" target="_blank" rel="external">View-Layer 协作</a>、<a href="http://yun.baidu.com/share/link?shareid=2268593032&amp;uk=2885973690" target="_blank" rel="external">sunnyxx关于runloop的线下视频</a>、<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>后加上自己的个人总结，各个资料有些说法都有差异，自己有整理有验证，也还存有疑惑，放上来希望得到指正。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/10/17/【OC刨根问底】-Runtime简单粗暴理解/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">【OC刨根问底】-Runtime简单粗暴理解</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="【iOS程序启动与运转】- RunLoop个人小结" data-title="【iOS程序启动与运转】- RunLoop个人小结.md" data-url="http://Alfred1003.github.io/2015/10/20/【iOS程序启动与运转】- RunLoop个人小结/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 楚天舒
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>